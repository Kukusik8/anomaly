1. ОШИБКА ПРИ ОТКРЫТИИ ITEM
     когда обрабатываем items в SinglePage.tsx в строке {item!.id} пытаемся получить свойство которое может быть null, (оно по умолчанию null) , поэтому ошибка Cannot read properties of null (reading 'id')
     плюс мы используем оператор "!.", который означает что точно не null | undefined, но у нас данные еще не подгрузились  - поэтому ошибка. Это не совсем безопасно, поэтому лучше использовать обычную проверку на null | undefined
     Поэтому нужно обезопасить этот момент каким то fallback(setError) и доп индикатор загрузки(setLoading) для улучшения UX, до этого мы не отслеживаем состояние загрузки item.
     Также не был прокинут id в зависимости useEffect. это нужно, чтобы компонент реагировал на изменение параметра роута в URL



2. SET ACTIVE BTN (pin item)
    в Button.tsx мы используем useCallback для мемоизации, но проблема в том что мы ни за чем не следим.Поэтому отработает только при монтировании. У нас есть id и onClick, которые изменяются при рендере, поэтому их нужно прокинуть в массив
    функция onClick для кнопки всегда будет ссылаться на первое созданное состояние. Соответственно, изменения в функциях или состоянии родительского компонента игнорируются.
    Также думаю стоит убрать оборачивание route кнопки в компоненте ListItem  потому что нам не нужен переход при клике на setActive, И сама суть кнопки расширена(кнопка должна выполнять одно действие). Если я правильно понял логику.
    Также нам нужно обновить родительский компонет. Аналогичная ситуация как и с useCallback, useEffect. Переменная activeItemText не обновляется когда меняется activeItemId

    *Возможные лучшение: не очень корректно перегружать кнопку. То есть компоненту передаётся не только onClick, но и id.  Кнопка-абстрактна. логику с id надо вешать на уровне компонента ListItem


3. АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ ДАННЫХ
    Чтобы показать обновление нам нужно ловить состояние в listPage
    В хуке useData добавил обработку состояний загрузки и обновления. Возвращаем эти состояния для использования в компоненте ListPage
    вытаскиваем эти состояния в listpage в зависимости от условия


4. СОРТИРОВКА
    Не рекомендуется мутировать массив из хука (используем sort. Можно использовать либо toSort() либо spread)
    Также добавлен функционал сортировки по убывания
    Логика функции handleSortClick нечитаема и непонятна. Лучше использовать тернарный оператор


5. ПОИСК ПО ID
    Использование регулярного выражение - избыточно. Экранировать *.?/ не имеет смысла, потому что никакой id априори не может быть найден с такими символами. Достаточно использовать includes()
    Исправлена ошибка в  компоненте ListPage в useEffect. Когда передаем filteredItems это вызовет бесконечный цикл, потому что каждый раз при вызове setFilteredItems обновляется этот массив поэтому нам нужно фильтровать на основе sortedItems, а не filtered.
    Также исправлен fallback если не найдено элемента из поиска
    Также используется в качестве ключа используется индекс в ListItem, тут думаю комментарии излишни:) так как у нас динамический массив


*В конце добавил минимальную типизиацию
